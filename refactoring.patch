diff --git a/.bumpversion.cfg b/.bumpversion.cfg
new file mode 100644
index 0000000..75bc447
--- /dev/null
+++ b/.bumpversion.cfg
@@ -0,0 +1,21 @@
+[bumpversion]
+current_version = 0.0.1-dev2
+commit = True
+tag = False
+parse = (?P<major>\d+)\.(?P<minor>\d+)\.(?P<patch>\d+)(\-(?P<release>[a-z]+)(?P<build>\d+))?
+serialize = 
+	{major}.{minor}.{patch}-{release}{build}
+	{major}.{minor}.{patch}
+
+[bumpversion:part:release]
+optional_value = prod
+first_value = dev
+values = 
+	dev
+	prod
+
+[bumpversion:part:build]
+
+[bumpversion:file:VERSION]
+
+[bumpversion:file:./tock/__version__.py]
diff --git a/Makefile b/Makefile
index 3148ea7..7598bfb 100644
--- a/Makefile
+++ b/Makefile
@@ -3,6 +3,26 @@ clean-build:
 	rm --force --recursive dist/
 	rm --force --recursive *.egg-info
 
+bump-snapshot: clean-build
+	bumpversion build;
+	python setup.py sdist;
+	twine upload dist/*
+
+bump-release-major: clean-build
+	bumpversion major;
+	python setup.py sdist;
+	twine upload dist/*
+
+bump-release-minor: clean-build
+	bumpversion major;
+	python setup.py sdist;
+	twine upload dist/*
+
+bump-release-patch: clean-build
+	bumpversion major;
+	python setup.py sdist;
+	twine upload dist/*
+
 install:
 	pip install -r requirements.txt
 
diff --git a/README.md b/README.md
index 3428cf1..11a7cf0 100644
--- a/README.md
+++ b/README.md
@@ -13,7 +13,6 @@ Build chatbots using Tock and Python
     - Managing User / conversational context
     - Testing
     - Packaging
- - Mainteners wanted
     
 ## Prerequisites
 
@@ -32,7 +31,6 @@ Install dependencies
 
     $ make init
 
-
 ## Usage Websocket mode
 
     from tock.bot import TockBot
@@ -43,7 +41,6 @@ Install dependencies
 
     bot.start_websocket(apikey=os.environ['TOCK_APIKEY'])
 
-
 ## Usage Webhook mode
 
     from tock.bot import TockBot
@@ -52,4 +49,4 @@ Install dependencies
 
     bot.add_story('greetings', lambda send: send(text="Greetings StoryHander !!!!"))
 
-    bot.start_webhook(host='0.0.0.0', path=os.environ['TOCK_WEBHOOK_PATH'], port=5000)
+    bot.start_webhook(host='0.0.0.0', path=os.environ['TOCK_WEBHOOK_PATH'], port=5000)
\ No newline at end of file
diff --git a/VERSION b/VERSION
new file mode 100644
index 0000000..3fd928f
--- /dev/null
+++ b/VERSION
@@ -0,0 +1 @@
+0.0.1-dev2
\ No newline at end of file
diff --git a/demo-bot.py b/demo-bot.py
deleted file mode 100644
index 148b461..0000000
--- a/demo-bot.py
+++ /dev/null
@@ -1,27 +0,0 @@
-# -*- coding: utf-8 -*-
-import logging
-import os
-
-from tock.bot import TockBot
-
-logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.DEBUG)
-
-# asyncio.get_event_loop().set_debug(True)
-
-bot = TockBot()
-
-bot.add_story('greetings', lambda send: send(text="Greetings StoryHander !!!!"))
-
-
-def goodbye_handler(send):
-    send(text="Goodbye1 StoryHander !!!!")
-    send(text="Goodbye2 StoryHander !!!!")
-    send(text="Goodbye3 StoryHander !!!!")
-
-
-bot.add_story('goodbye', goodbye_handler)
-
-bot.add_story('gratitude', lambda send: send(text="Gratitude StoryHander !!!!"))
-
-bot.start_websocket(apikey=os.environ['TOCK_APIKEY'])
-#bot.start_webhook(host='0.0.0.0', path=os.environ['TOCK_WEBHOOK_PATH'], port=5000)
diff --git a/demo_bot.py b/demo_bot.py
new file mode 100644
index 0000000..7825398
--- /dev/null
+++ b/demo_bot.py
@@ -0,0 +1,125 @@
+# -*- coding: utf-8 -*-
+import logging
+import os
+from typing import List
+
+from tock.bot import TockBot
+from tock.bus import TockBotBus
+from tock.intent import Intent
+from tock.models import Sentence, Card, AttachmentType, Carousel
+from tock.story import Story, story
+
+logging.basicConfig(
+    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
+    level=logging.DEBUG
+)
+
+# asyncio.get_event_loop().set_debug(True)
+
+class DemoBotBus(TockBotBus):
+
+    @property
+    def person(self) -> str:
+        entity = self.context.entity("person")
+        if entity:
+            return entity.content
+
+
+@story(
+    intent="biography",
+    other_starter_intents=["person"],
+    secondary_intents=["birthdate"]
+)
+def culture(bus: DemoBotBus):
+    def ask_person():
+        bus.send(
+            Sentence.Builder(f"Who do you want to see?")
+                .add_suggestion("Mozart")
+                .add_suggestion("Molière")
+                .add_suggestion("Napoléon")
+                .build()
+        )
+
+    def answer_birthdate():
+        bus.send(
+            Sentence.Builder(f"{bus.person} was born in 1500")
+                .add_suggestion("En savoir plus")
+                .build()
+        )
+
+    def answer_biography():
+        bus.send(
+            Sentence.Builder(f"{bus.person} was a great person !!!")
+                .add_suggestion("En savoir plus")
+                .build()
+        )
+
+    person_undefined: bool = bus.person is None
+    ask_birthdate: bool = bus.is_intent("birthdate")
+
+    if person_undefined:
+        ask_person()
+    elif ask_birthdate:
+        answer_birthdate()
+    else:
+        answer_biography()
+
+
+class GreetingStory(Story):
+
+    @staticmethod
+    def intent() -> Intent:
+        return Intent("greetings")
+
+    @staticmethod
+    def other_starter_intents() -> List[Intent]:
+        return []
+
+    @staticmethod
+    def secondary_intents() -> List[Intent]:
+        return []
+
+    def answer(self, bus: DemoBotBus):
+        bus.send(Sentence.Builder("Message from greeting story").build())
+        card = Card \
+            .Builder() \
+            .with_title("Card title") \
+            .with_sub_title("Card sub title") \
+            .with_attachment("https://www.sncf.com/themes/sncfcom/img/favicon.png", AttachmentType.IMAGE) \
+            .add_action("visit", "http://www.sncf.com") \
+            .build()
+        bus.send(
+            card
+        )
+        bus.send(
+            Carousel
+                .Builder()
+                .add_card(card)
+                .add_card(card)
+                .add_card(card)
+                .build()
+        )
+
+
+def goodbye(bus: DemoBotBus):
+    bus.send("Goodbye message 1!!!!")
+    bus.send("Goodbye message 2!!!!")
+
+
+def error(bus: DemoBotBus):
+    bus.send(Sentence.Builder("Error StoryHander !!!!")
+             .add_suggestion("Retry")
+             .build())
+
+
+TockBot() \
+    .namespace("elebescond") \
+    .register_bus(DemoBotBus) \
+    .register_story(GreetingStory) \
+    .register_story(culture()) \
+    .add_story('goodbye', goodbye) \
+    .error_handler(error) \
+    .start_websocket(apikey=os.environ['TOCK_APIKEY'])
+# .start_websocket(apikey=os.environ['TOCK_APIKEY'], host="bot-api", port=80, protocol="ws")
+
+# .start_webhook(host='0.0.0.0', path=os.environ['TOCK_WEBHOOK_PATH'], port=5000)
diff --git a/requirements.txt b/requirements.txt
index d3ea513..d16787f 100644
--- a/requirements.txt
+++ b/requirements.txt
@@ -1,3 +1,6 @@
-aiohttp
-asyncio
-marshmallow
+aiohttp==3.6.2
+asyncio==3.4.3
+marshmallow==3.7.1
+marshmallow_enum==1.5.1
+marshmallow-oneofschema==2.0.1
+testfixtures==6.14.2
\ No newline at end of file
diff --git a/setup.cfg b/setup.cfg
new file mode 100644
index 0000000..224a779
--- /dev/null
+++ b/setup.cfg
@@ -0,0 +1,2 @@
+[metadata]
+description-file = README.md
\ No newline at end of file
diff --git a/setup.py b/setup.py
index fb02794..4e9b174 100644
--- a/setup.py
+++ b/setup.py
@@ -1,11 +1,30 @@
+import os
+import re
+
 import setuptools
 
 with open("README.md", "r") as fh:
     long_description = fh.read()
 
+PKG = "tock"
+VERSIONFILE = os.path.join(PKG, "__version__.py")
+
+try:
+    verstrline = open(VERSIONFILE, "rt").read()
+except EnvironmentError:
+    pass  # Okay, there is no version file.
+else:
+    VSRE = r"^verstr = ['\"]([^'\"]*)['\"]"
+    mo = re.search(VSRE, verstrline, re.M)
+    if mo:
+        version = mo.group(1)
+    else:
+        print("unable to find version in %s" % (VERSIONFILE,))
+        raise RuntimeError("if %s.py exists, it is required to be well-formed" % (VERSIONFILE,))
+
 setuptools.setup(
     name="tock-py",
-    version="0.0.1",
+    version=version,
     author="Erwan LE BESCOND",
     author_email="elebescond@gmail.com",
     description="Build chatbots using Tock and Python",
@@ -13,10 +32,18 @@ setuptools.setup(
     long_description_content_type="text/markdown",
     url="https://github.com/theopenconversationkit/tock-py/",
     packages=setuptools.find_packages(),
+    install_requires=[
+        'aiohttp==3.6.2',
+        'asyncio==3.4.3',
+        'marshmallow==3.7.1',
+        'marshmallow_enum==1.5.1',
+        'marshmallow-oneofschema==2.0.1',
+        'testfixtures==6.14.2',
+    ],
     classifiers=[
         "Programming Language :: Python :: 3",
         "License :: OSI Approved :: MIT License",
         "Operating System :: OS Independent",
     ],
     python_requires='>=3.6',
-)
\ No newline at end of file
+)
diff --git a/tock/__init__.py b/tock/__init__.py
index b8023d8..e69de29 100644
--- a/tock/__init__.py
+++ b/tock/__init__.py
@@ -1 +0,0 @@
-__version__ = '0.0.1'
diff --git a/tock/__version__.py b/tock/__version__.py
new file mode 100644
index 0000000..2644688
--- /dev/null
+++ b/tock/__version__.py
@@ -0,0 +1 @@
+verstr = '0.0.1-dev2'
diff --git a/tock/bot.py b/tock/bot.py
index 714d993..f517c36 100644
--- a/tock/bot.py
+++ b/tock/bot.py
@@ -1,10 +1,28 @@
 # -*- coding: utf-8 -*-
-from typing import Callable
+"""
+    The ``bot`` module
+    ======================
 
+    Use it to init a Tock BOT.
+
+    :Example:
+
+    >>> import os
+    >>>> from tock.bot import TockBot
+    >>> TockBot().namespace("my-bot").start_websocket(apikey=os.environ['TOCK_APIKEY'])
+
+"""
 import asyncio
+import logging
+from datetime import datetime
+from typing import Callable, Type, List
 
-from tock.helpers import buildBotResponse, buildMessage
+from tock.bus import TockBotBus, BotBus
+from tock.context import Context
+from tock.intent import IntentName, Intent
+from tock.models import TockMessage, BotRequest, BotMessage, BotResponse, ResponseContext
 from tock.schemas import TockMessageSchema
+from tock.story import Story, ErrorStory, Stories, story
 from tock.webhook import TockWebhook
 from tock.websocket import TockWebsocket
 
@@ -12,10 +30,34 @@ from tock.websocket import TockWebsocket
 class TockBot:
 
     def __init__(self):
-        self.__story_handlers = {}
+        self.__logger: logging.Logger = logging.getLogger(__name__)
+        self.__namespace: str = "default"
+        self.__bus = TockBotBus
+        self.__stories = Stories()
+        self.__error_handler: Callable = lambda send: send("Default error handler")
+        self.__context = Context()
+
+    def namespace(self, namespace: str):
+        self.__namespace = namespace
+        return self
+
+    def register_bus(self, bus: BotBus):
+        self.__bus = bus
+        return self
+
+    def error_handler(self, handler: Callable):
+        self.__error_handler = handler
+        return self
+
+    def add_story(self, intent_name: IntentName, answer: Callable):
+        story_class: Type[Story] = story(intent_name)(answer)()
 
-    def add_story(self, intent: str, handler: Callable):
-        self.__story_handlers[intent] = handler
+        self.register_story(story_class)
+        return self
+
+    def register_story(self, story: Type[Story]):
+        self.__stories.register_story(story)
+        return self
 
     def start_webhook(self,
                       host: str,
@@ -42,15 +84,56 @@ class TockBot:
             bot_handler=self.__bot_handler
         ).start())
 
-    def __bot_handler(self, bot_request):
-        tock_message = TockMessageSchema().load(bot_request)
-        messages = []
-        self.__story_handlers[tock_message.bot_request.intent](
-            lambda text: messages.append(buildMessage(text=text))
+    def __bot_handler(self, tock_message: TockMessage) -> str:
+        messages: List[BotMessage] = []
+        request: BotRequest = tock_message.bot_request
+
+        story_class: Type[Story] = self.__stories.find_story(Intent(request.intent), self.__context.current_story)
+
+        self.__context.entities = self.__context.entities + request.entities
+        self.__context.current_story = story_class
+        bus = self.__bus(
+            context=self.__context,
+            send=lambda bot_message: messages.append(bot_message),
+            request=request
         )
-        response = buildBotResponse(
+
+        if story_class is not None:
+            self.__logger.info("story found %s for intent %s", story_class.__name__, request.intent)
+            story = self.__create(story_class, bus)
+        else:
+            self.__logger.info("No story for intent %s", request.intent)
+            story = ErrorStory(request=request, answer=self.__error_handler)
+
+        try:
+            story.answer(bus)
+        except:
+            self.__logger.exception("Unexpected error")
+
+        response = TockMessage(
+            bot_response=BotResponse(
+                messages=messages,
+                story_id="story_id",
+                step=None,
+                context=ResponseContext(
+                    request_id=tock_message.request_id,
+                    date=datetime.now()
+                ),
+                entities=[]
+            ),
             request_id=tock_message.request_id,
-            messages=messages
         )
-        tock_response = TockMessageSchema().dumps(response)
+        tock_response: str = TockMessageSchema().dumps(response)
         return tock_response
+
+    def __create(self, story_class: Type[Story], bus: BotBus):
+        story = story_class(request=bus.request)
+        for entity in bus.context.entities:
+            entity_type = entity.type.split(":")[1]
+            if hasattr(story, entity_type):
+                setattr(
+                    story,
+                    entity_type,
+                    entity.content
+                )
+        return story
diff --git a/tock/bus.py b/tock/bus.py
new file mode 100644
index 0000000..eacda7b
--- /dev/null
+++ b/tock/bus.py
@@ -0,0 +1,78 @@
+# -*- coding: utf-8 -*-
+import abc
+from typing import Callable, List, Union
+
+from tock.intent import Intent, Intent, IntentName
+from tock.context import Context
+from tock.models import BotMessage, BotRequest, Entity, Sentence
+
+
+class BotBus(abc.ABC):
+
+    @abc.abstractmethod
+    def send(self, message: BotMessage):
+        pass
+
+    @property
+    @abc.abstractmethod
+    def context(self) -> Context:
+        pass
+
+    @property
+    @abc.abstractmethod
+    def intent(self) -> Intent:
+        pass
+
+    @property
+    @abc.abstractmethod
+    def request(self) -> BotRequest:
+        pass
+
+    @abc.abstractmethod
+    def entity(self, entity_type: str) -> Entity:
+        pass
+
+    @abc.abstractmethod
+    def is_intent(self, intents: List[Intent]) -> bool:
+        pass
+
+
+class TockBotBus(BotBus):
+
+    def __init__(self,
+                 context: Context,
+                 send: Callable,
+                 request: BotRequest
+                 ):
+        self.__context = context
+        self.__send = send
+        self.__request = request
+
+    def send(self, message: Union[str, BotMessage]):
+        if type(message) == str:
+            message = Sentence.Builder(message).build()
+        self.__send(message)
+
+    @property
+    def context(self):
+        return self.__context
+
+    @property
+    def intent(self) -> Intent:
+        return Intent(self.__request.intent)
+
+    @property
+    def request(self):
+        return self.__request
+
+    def entity(self, entity_type: str) -> Entity:
+        return self.context.entity(entity_type)
+
+    def is_intent(self, intents: Union[IntentName, Intent, List[IntentName], List[Intent]]) -> bool:
+        if type(intents) == IntentName:
+            intents = [Intent(intents)]
+        elif type(intents) == Intent:
+            intents = [intents]
+        elif type(intents) == List[IntentName]:
+            intents = map(Intent, intents)
+        return self.intent in intents
diff --git a/tock/connector.py b/tock/connector.py
new file mode 100644
index 0000000..71600b0
--- /dev/null
+++ b/tock/connector.py
@@ -0,0 +1,16 @@
+# -*- coding: utf-8 -*-
+import abc
+
+
+class Connector(abc.ABC):
+
+    @abc.abstractmethod
+    def send(self, message: str):
+        pass
+
+
+class BaseConnector(Connector):
+
+    def send(self, message: str):
+        print(message)
+        pass
diff --git a/tock/context.py b/tock/context.py
new file mode 100644
index 0000000..3b534ad
--- /dev/null
+++ b/tock/context.py
@@ -0,0 +1,25 @@
+# -*- coding: utf-8 -*-
+from re import split
+from typing import Type, Optional, List
+
+from tock.intent import Intent
+from tock.models import Entity
+
+
+class Context:
+
+    def __init__(self, previous_intent: Optional[Intent] = None, current_story: Optional[Type] = None):
+        self.current_story: Optional[Type] = current_story
+        self.entities = []
+        self.__previous_intent: Optional[Intent] = previous_intent
+
+    def entity(self, entity_type: str) -> Optional[Entity]:
+        for entity in reversed(self.entities):
+            parts = split(':', entity.type)
+            parts.reverse()
+            if parts[0] == entity_type:
+                return entity
+
+    @property
+    def previous_intent(self):
+        return self.__previous_intent
diff --git a/tock/helpers.py b/tock/helpers.py
deleted file mode 100644
index 6237f2b..0000000
--- a/tock/helpers.py
+++ /dev/null
@@ -1,32 +0,0 @@
-# -*- coding: utf-8 -*-
-from datetime import datetime
-
-
-#  TODO Using classes models.py
-def buildMessage(text):
-    return {
-        "delay": 0,
-        "suggestions": [],
-        "text": {
-            "text": text,
-            "args": [],
-            "toBeTranslated": True,
-            "length": text.__len__()
-        },
-        "type": "sentence"
-    }
-
-
-def buildBotResponse(request_id, messages):
-    return {
-        "botResponse": {
-            "context": {
-                "date": datetime.now(),
-                "requestId": request_id
-            },
-            "entities": [],
-            "messages": messages,
-            "storyId": "python_story"
-        },
-        "requestId": request_id
-    }
diff --git a/tock/intent.py b/tock/intent.py
new file mode 100644
index 0000000..8255b8b
--- /dev/null
+++ b/tock/intent.py
@@ -0,0 +1,18 @@
+# -*- coding: utf-8 -*-
+"""
+    The ``intent`` module
+    ======================
+
+    Use it to import very intent kinds.
+
+    :Example:
+
+    >>> from tock.intent import Intent
+    >>> Intent(name = "greetings")
+    Intent(name='greetings')
+
+"""
+from collections import namedtuple
+
+IntentName = str
+Intent = namedtuple('Intent', ['name'])
diff --git a/tock/models.py b/tock/models.py
index 407a01f..4413030 100644
--- a/tock/models.py
+++ b/tock/models.py
@@ -1,11 +1,16 @@
 # -*- coding: utf-8 -*-
+import abc
 from datetime import datetime
 from enum import Enum
+from re import split
+from typing import List, Union, Optional
+
+from tock.intent import IntentName
 
 
 class PlayerType(Enum):
-    USER = 'user'
-    BOT = 'bot'
+    USER = "user"
+    BOT = "bot"
 
 
 class Entity:
@@ -16,7 +21,7 @@ class Entity:
         self.content = content
         self.value = value
         self.evaluated = evaluated
-        self.subEntities = []
+        self.sub_entities = []
         self.new = new
 
 
@@ -29,17 +34,17 @@ class Message:
 
 class ConnectorType:
 
-    def __init__(self, id: str, userInterfaceType: str):
+    def __init__(self, id: str, user_interface_type: str):
         self.id = id
-        self.user_interface_type = userInterfaceType
+        self.user_interface_type = user_interface_type
 
 
 class UserId:
 
-    def __init__(self, id: str, type: PlayerType, clientId: str = None):
+    def __init__(self, id: str, type: PlayerType, client_id: str = None):
         self.id = id
         self.type = type
-        self.client_id = clientId
+        self.client_id = client_id
 
 
 class User:
@@ -52,65 +57,254 @@ class User:
 
 class RequestContext:
 
-    def __init__(self, namespace: str, language: str, connectorType: ConnectorType, userInterface: str, applicationId: str, userId: UserId,
-                 botId: UserId, user: User):
+    def __init__(self,
+                 namespace: str,
+                 language: str,
+                 connector_type: ConnectorType,
+                 user_interface: str,
+                 application_id: str,
+                 user_id: UserId,
+                 bot_id: UserId,
+                 user: User):
         self.namespace = namespace
         self.language = language
-        self.connector_type = connectorType
-        self.user_interface = userInterface
-        self.application_id = applicationId
-        self.user_id = userId
-        self.bot_id = botId
+        self.connector_type = connector_type
+        self.user_interface = user_interface
+        self.application_id = application_id
+        self.user_id = user_id
+        self.bot_id = bot_id
         self.user = user
 
 
-class Suggestion:
-
-    def __init__(self, title: str):
-        self.title = title
-
-
 class I18nText:
 
-    def __init__(self, text: str, args: [], toBeTranslated: bool, length: int, key: str = None):
+    def __init__(self,
+                 text: str,
+                 args: [],
+                 to_be_translated: bool,
+                 length: int,
+                 key: Optional[str] = None
+                 ):
         self.text = text
         self.args = args
-        self.to_be_translated = toBeTranslated
+        self.to_be_translated = to_be_translated
         self.length = length
         self.key = key
 
 
-class BotMessageSentence:
+class Suggestion:
+
+    def __init__(self, title: I18nText):
+        self.title = title
+
+
+class BotMessage(abc.ABC):
+
+    def __init__(self, delay: int = 0):
+        self.delay = delay
+
+
+class Sentence(BotMessage):
 
-    def __init__(self, text: str, suggestions: [], delay: int):
+    def __init__(self,
+                 text: I18nText,
+                 suggestions: List[Suggestion],
+                 delay: int):
         self.text = text
         self.suggestions = suggestions
-        self.delay = delay
-        self.type = 'sentence'
+        super().__init__(delay)
+
+    class Builder:
+
+        def __init__(self, text: str):
+            self.__text = text
+            self.__suggestions = []
+            self.__delay = 0
+
+        def with_text(self, text: Union[str, I18nText]):
+            if isinstance(text, I18nText):
+                self.__text = text
+            else:
+                self.__text = I18nText(
+                    text=text,
+                    args=[],
+                    to_be_translated=True,
+                    length=len(text)
+                )
+            return self
+
+        def add_suggestion(self, title: str):
+            self.__suggestions.append(Suggestion(
+                title=I18nText(
+                    text=title,
+                    args=[],
+                    to_be_translated=True,
+                    length=len(self.__text)
+                )
+            ))
+            return self
+
+        def with_delay(self, delay: int):
+            self.__delay = delay
+            return self
+
+        def build(self):
+            return Sentence(
+                text=I18nText(
+                    text=self.__text,
+                    args=[],
+                    to_be_translated=True,
+                    length=len(self.__text)
+                ),
+                suggestions=self.__suggestions,
+                delay=self.__delay
+            )
+
+
+class AttachmentType(Enum):
+    IMAGE = "image"
+    AUDIO = "audio"
+    VIDEO = "video"
+    FILE = "file"
+
+
+class Attachment:
+
+    def __init__(self, url: str, type: Optional[AttachmentType]):
+        self.url = url
+        self.type = type
+
+
+class Action:
+
+    def __init__(self, title: I18nText, url: Optional[str]):
+        self.title = title
+        self.url = url
+
+
+class Card(BotMessage):
+
+    def __init__(self,
+                 title: Optional[I18nText],
+                 sub_title: Optional[I18nText],
+                 attachment: Optional[Attachment],
+                 actions: List[Action],
+                 delay: int):
+        self.title = title
+        self.sub_title = sub_title
+        self.attachment = attachment
+        self.actions = actions
+        super().__init__(delay)
+
+    class Builder:
+
+        def __init__(self):
+            self.__title = None
+            self.__sub_title = None
+            self.__attachment = None
+            self.__actions: List[Action] = []
+            self.__delay = 0
+
+        def with_title(self, title: Union[str, I18nText]):
+            if isinstance(title, I18nText):
+                self.__title = title
+            else:
+                self.__title = I18nText(
+                    text=title,
+                    args=[],
+                    to_be_translated=True,
+                    length=len(title)
+                )
+            return self
+
+        def with_sub_title(self, sub_title: Union[str, I18nText]):
+            if isinstance(sub_title, I18nText):
+                self.__sub_title = sub_title
+            else:
+                self.__sub_title = I18nText(
+                    text=sub_title,
+                    args=[],
+                    to_be_translated=True,
+                    length=len(sub_title)
+                )
+            return self
+
+        def with_attachment(self, url: str, type: AttachmentType = None):
+            self.__attachment = Attachment(url, type)
+            return self
+
+        def add_action(self, title: Union[str, I18nText], url: str):
+            if not isinstance(title, I18nText):
+                title = I18nText(
+                    text=title,
+                    args=[],
+                    to_be_translated=True,
+                    length=len(title)
+                )
+            self.__actions.append(Action(title=title, url=url))
+            return self
+
+        def with_delay(self, delay: int):
+            self.__delay = delay
+            return self
+
+        def build(self):
+            return Card(
+                title=self.__title,
+                sub_title=self.__sub_title,
+                attachment=self.__attachment,
+                actions=self.__actions,
+                delay=self.__delay
+            )
+
+
+class Carousel(BotMessage):
+
+    def __init__(self, cards: List[Card], delay: int):
+        self.cards = cards
+        super().__init__(delay)
+
+    class Builder:
+
+        def __init__(self):
+            self.__cards: List[Card] = []
+            self.__delay = 0
+
+        def add_card(self, card: Card):
+            self.__cards.append(card)
+            return self
+
+        def build(self):
+            return Carousel(
+                cards=self.__cards,
+                delay=self.__delay
+            )
 
 
 class ResponseContext:
 
-    def __init__(self, requestId: str, date: datetime):
-        self.request_id = requestId
+    def __init__(self, request_id: str, date: datetime):
+        self.request_id = request_id
         self.date = date
 
 
 class BotRequest:
 
-    def __init__(self, intent: str, entities: [], message: Message, storyId: str, context: RequestContext):
+    def __init__(self, intent: IntentName, entities: List[Entity], message: Message, story_id: str,
+                 request_context: RequestContext = None):
         self.intent = intent
         self.entities = entities
         self.message = message
-        self.story_id = storyId
-        self.context = context
+        self.story_id = story_id
+        self.request_context = request_context
 
 
 class BotResponse:
 
-    def __init__(self, messages, storyId: str, entities: [], context: ResponseContext, step: str = None):
+    def __init__(self, messages: List[BotMessage], story_id: str, step: str, context: ResponseContext,
+                 entities: List[Entity]):
         self.messages = messages
-        self.story_id = storyId
+        self.story_id = story_id
         self.step = step
         self.entities = entities
         self.context = context
@@ -118,7 +312,7 @@ class BotResponse:
 
 class TockMessage:
 
-    def __init__(self, requestId: str, botRequest: BotRequest = None, botResponse: BotResponse = None):
-        self.bot_request = botRequest
-        self.bot_response = botResponse
-        self.request_id = requestId
+    def __init__(self, request_id: str, bot_request: BotRequest = None, bot_response: BotResponse = None):
+        self.bot_request = bot_request
+        self.bot_response = bot_response
+        self.request_id = request_id
diff --git a/tock/schemas.py b/tock/schemas.py
index 72b71ea..10798d3 100644
--- a/tock/schemas.py
+++ b/tock/schemas.py
@@ -1,8 +1,16 @@
 # -*- coding: utf-8 -*-
-from marshmallow import Schema, fields, EXCLUDE, post_load, validate
+from marshmallow import Schema, fields, EXCLUDE, post_load
+from marshmallow_enum import EnumField
+from marshmallow_oneofschema import OneOfSchema
 
-from tock.models import TockMessage, BotRequest, User, UserId, ConnectorType, Message, Entity, RequestContext, BotResponse, ResponseContext, \
-    BotMessageSentence, I18nText, Suggestion
+from tock.models import TockMessage, BotRequest, User, UserId, ConnectorType, Message, Entity, RequestContext, \
+    BotResponse, ResponseContext, \
+    Sentence, I18nText, Suggestion, PlayerType, Card, AttachmentType, Attachment, Action, Carousel
+
+
+def camelcase(s):
+    parts = iter(s.split("_"))
+    return next(parts) + "".join(i.title() for i in parts)
 
 
 class EntitySchema(Schema):
@@ -36,25 +44,31 @@ class MessageSchema(Schema):
 
 class ConnectorTypeSchema(Schema):
     id = fields.String(required=True)
-    userInterfaceType = fields.String(required=True)
+    user_interface_type = fields.String(required=True)
 
     @post_load
     def make_connector_type(self, data, **kwargs):
         return ConnectorType(**data)
 
+    def on_bind_field(self, field_name, field_obj):
+        field_obj.data_key = camelcase(field_obj.data_key or field_name)
+
     class Meta:
         unknown = EXCLUDE
 
 
 class UserIdSchema(Schema):
     id = fields.String(required=True)
-    type = fields.String(required=True, validate=validate.OneOf(['bot', 'user']))
-    clientId = fields.String(required=True, allow_none=True)
+    type = EnumField(PlayerType, by_value=True)
+    client_id = fields.String(required=True, allow_none=True)
 
     @post_load
     def make_user_id(self, data, **kwargs):
         return UserId(**data)
 
+    def on_bind_field(self, field_name, field_obj):
+        field_obj.data_key = camelcase(field_obj.data_key or field_name)
+
     class Meta:
         unknown = EXCLUDE
 
@@ -75,12 +89,15 @@ class UserSchema(Schema):
 class RequestContextSchema(Schema):
     namespace = fields.String(required=True)
     language = fields.String(required=True)
-    connectorType = fields.Nested(ConnectorTypeSchema())
-    userInterface = fields.String(required=True)
-    applicationId = fields.String(required=True)
-    userId = fields.Nested(UserIdSchema())
-    botId = fields.Nested(UserIdSchema())
-    user = fields.Nested(UserSchema())
+    connector_type = fields.Nested(ConnectorTypeSchema)
+    user_interface = fields.String(required=True)
+    application_id = fields.String(required=True)
+    user_id = fields.Nested(UserIdSchema)
+    bot_id = fields.Nested(UserIdSchema)
+    user = fields.Nested(UserSchema)
+
+    def on_bind_field(self, field_name, field_obj):
+        field_obj.data_key = camelcase(field_obj.data_key or field_name)
 
     @post_load
     def make_request_context(self, data, **kwargs):
@@ -90,8 +107,26 @@ class RequestContextSchema(Schema):
         unknown = EXCLUDE
 
 
+class I18nTextSchema(Schema):
+    text = fields.String(required=True)
+    args = fields.List(fields.String, required=True)
+    to_be_translated = fields.Boolean(required=True)
+    length = fields.Integer(required=True)
+    key = fields.String(required=False, allow_none=True)
+
+    def on_bind_field(self, field_name, field_obj):
+        field_obj.data_key = camelcase(field_obj.data_key or field_name)
+
+    @post_load
+    def make_i18n_text(self, data, **kwargs):
+        return I18nText(**data)
+
+    class Meta:
+        unknown = EXCLUDE
+
+
 class SuggestionSchema(Schema):
-    title = fields.String(required=True)
+    title = fields.Nested(I18nTextSchema, required=True)
 
     @post_load
     def make_suggestion(self, data, **kwargs):
@@ -101,42 +136,113 @@ class SuggestionSchema(Schema):
         unknown = EXCLUDE
 
 
-class I18nTextSchema(Schema):
-    text = fields.String(required=True)
-    args = fields.List(fields.String, required=True)
-    toBeTranslated = fields.Boolean(required=True)
-    length = fields.Integer(required=True)
-    key = fields.String(required=False, allow_none=True)
+class AttachmentSchema(Schema):
+    url = fields.String(required=True)
+    type = EnumField(AttachmentType, by_value=True, required=False)
+
+    def on_bind_field(self, field_name, field_obj):
+        field_obj.data_key = camelcase(field_obj.data_key or field_name)
 
     @post_load
-    def make_i18n_text(self, data, **kwargs):
-        return I18nText(**data)
+    def make_attachment(self, data, **kwargs):
+        return Attachment(**data)
+
+    class Meta:
+        unknown = EXCLUDE
+
+
+class ActionSchema(Schema):
+    title = fields.Nested(I18nTextSchema)
+    url = fields.String(required=False)
+
+    @post_load
+    def make_suggestion(self, data, **kwargs):
+        return Action(**data)
 
     class Meta:
         unknown = EXCLUDE
 
 
 class BotMessageSchema(Schema):
-    type = fields.Str(validate=validate.OneOf(['sentence']))
+    delay = fields.Integer(required=False)
+
+    class Meta:
+        unknown = EXCLUDE
+
+
+class SentenceSchema(BotMessageSchema):
     text = fields.Nested(I18nTextSchema)
     suggestions = fields.List(fields.Nested(SuggestionSchema), required=True)
-    delay = fields.Integer(required=False)
 
     @post_load
-    def make_bot_message(self, data, **kwargs):
-        if (data['type'] == 'sentence'):
-            del data['type']
-            return BotMessageSentence(**data)
-        raise UnsupportedSchema
+    def make_sentence(self, data, **kwargs):
+        return Sentence(**data)
+
+    class Meta:
+        unknown = EXCLUDE
+
+
+class CardSchema(BotMessageSchema):
+    title = fields.Nested(I18nTextSchema, required=False)
+    sub_title = fields.Nested(I18nTextSchema, required=False)
+    attachment = fields.Nested(AttachmentSchema, required=False)
+    actions = fields.List(fields.Nested(ActionSchema), required=True)
+
+    def on_bind_field(self, field_name, field_obj):
+        field_obj.data_key = camelcase(field_obj.data_key or field_name)
+
+    @post_load
+    def make_card(self, data, **kwargs):
+        return Card(**data)
 
     class Meta:
         unknown = EXCLUDE
 
 
+class UberCardSchema(OneOfSchema):
+    type_field = "type"
+    type_schemas = {"card": CardSchema}
+
+    def get_obj_type(self, obj):
+        if isinstance(obj, Card):
+            return "card"
+        else:
+            raise Exception("Unknown object type: {}".format(obj.__class__.__name__))
+
+
+class CarouselSchema(BotMessageSchema):
+    cards = fields.List(fields.Nested(UberCardSchema), required=True)
+
+    @post_load
+    def make_carousel(self, data, **kwargs):
+        return Carousel(**data)
+
+    class Meta:
+        unknown = EXCLUDE
+
+
+class UberBotMessageSchema(OneOfSchema):
+    type_field = "type"
+    type_schemas = {"sentence": SentenceSchema, "card": CardSchema, "carousel": CarouselSchema}
+
+    def get_obj_type(self, obj):
+        if isinstance(obj, Sentence):
+            return "sentence"
+        elif isinstance(obj, Card):
+            return "card"
+        elif isinstance(obj, Carousel):
+            return "carousel"
+        else:
+            raise Exception("Unknown object type: {}".format(obj.__class__.__name__))
+
+
 class ResponseContextSchema(Schema):
-    requestId = fields.String(required=True)
+    request_id = fields.String(required=True)
     date = fields.DateTime(required=True)
 
+    def on_bind_field(self, field_name, field_obj):
+        field_obj.data_key = camelcase(field_obj.data_key or field_name)
+
     @post_load
     def make_response_context(self, data, **kwargs):
         return ResponseContext(**data)
@@ -150,8 +256,11 @@ class BotRequestSchema(Schema):
     intent = fields.String(required=True)
     entities = fields.List(fields.Nested(EntitySchema), required=True)
     message = fields.Nested(MessageSchema())
-    storyId = fields.String(required=True)
-    context = fields.Nested(RequestContextSchema())
+    story_id = fields.String(required=True)
+    request_context = fields.Nested(RequestContextSchema, required=False)
+
+    def on_bind_field(self, field_name, field_obj):
+        field_obj.data_key = camelcase(field_obj.data_key or field_name)
 
     @post_load
     def make_bot_request(self, data, **kwargs):
@@ -162,12 +271,15 @@ class BotRequestSchema(Schema):
 
 
 class BotResponseSchema(Schema):
-    messages = fields.List(fields.Nested(BotMessageSchema), required=True)
-    storyId = fields.String(required=True)
+    messages = fields.List(fields.Nested(UberBotMessageSchema), required=True)
+    story_id = fields.String(required=True)
     step = fields.String(required=False, allow_none=True)
     entities = fields.List(fields.Nested(EntitySchema), required=True)
     context = fields.Nested(ResponseContextSchema, required=True)
 
+    def on_bind_field(self, field_name, field_obj):
+        field_obj.data_key = camelcase(field_obj.data_key or field_name)
+
     @post_load
     def make_bot_response(self, data, **kwargs):
         return BotResponse(**data)
@@ -177,9 +289,12 @@ class BotResponseSchema(Schema):
 
 
 class TockMessageSchema(Schema):
-    botRequest = fields.Nested(BotRequestSchema(), required=False)
-    botResponse = fields.Nested(BotResponseSchema(), required=False)
-    requestId = fields.String(required=True)
+    bot_request = fields.Nested(BotRequestSchema, required=False)
+    bot_response = fields.Nested(BotResponseSchema, required=False)
+    request_id = fields.String(required=True)
+
+    def on_bind_field(self, field_name, field_obj):
+        field_obj.data_key = camelcase(field_obj.data_key or field_name)
 
     @post_load
     def make_tockmessage(self, data, **kwargs):
diff --git a/tock/story.py b/tock/story.py
new file mode 100644
index 0000000..b355ade
--- /dev/null
+++ b/tock/story.py
@@ -0,0 +1,113 @@
+# -*- coding: utf-8 -*-
+import abc
+from typing import Callable, Optional, Dict, Type, List
+
+from tock.bus import BotBus
+from tock.intent import Intent, Intent
+from tock.models import BotRequest
+
+
+class Story(abc.ABC):
+
+    def __init__(self, request: BotRequest):
+        self._request: BotRequest = request
+
+    @staticmethod
+    @abc.abstractmethod
+    def intent() -> Intent:
+        pass
+
+    @staticmethod
+    @abc.abstractmethod
+    def other_starter_intents() -> List[Intent]:
+        pass
+
+    @staticmethod
+    @abc.abstractmethod
+    def secondary_intents() -> List[Intent]:
+        pass
+
+    @staticmethod
+    def support(self, _intent: Intent) -> bool:
+        return self.intent() == _intent or _intent in self.other_starter_intents() or _intent in self.secondary_intents()
+
+    @abc.abstractmethod
+    def answer(self, bus: BotBus):
+        pass
+
+
+def story(intent: str, other_starter_intents=None, secondary_intents=None):
+    if secondary_intents is None:
+        secondary_intents = []
+    if other_starter_intents is None:
+        other_starter_intents = []
+
+    def decorator(answer):
+        def provide_story_class():
+            return type(
+                f"{intent.capitalize()}Story",
+                (Story, object),
+                {
+                    "intent": lambda: Intent(intent),
+                    "other_starter_intents": lambda: list(map(Intent, other_starter_intents)),
+                    "secondary_intents": lambda: list(map(Intent, secondary_intents)),
+                    "answer": lambda _, bus: answer(bus)
+                }
+            )
+
+        return provide_story_class
+
+    return decorator
+
+
+# TODO beurk
+class ErrorStory(Story):
+    @staticmethod
+    def other_starter_intents() -> List[Intent]:
+        pass
+
+    @staticmethod
+    def secondary_intents() -> List[Intent]:
+        pass
+
+    intent: Intent = None
+
+    def __init__(self, request: BotRequest, answer: Callable = lambda send: send("")):
+        self.__answer = answer
+        super().__init__(request)
+
+    def answer(self, bus: BotBus):
+        self.__answer(bus)
+
+
+class Stories:
+
+    def __init__(self):
+        self.__stories_by_main_intent: Dict[Intent, Type[Story]] = {}
+        self.__stories_by_other_starter_intents: Dict[Intent, List[Type[Story]]] = {}
+        self.__stories_by_secondary_intents: Dict[Intent, List[Type[Story]]] = {}
+
+    def register_story(self, story_class: Type[Story]):
+
+        self.__stories_by_main_intent[story_class.intent()] = story_class
+
+        for intent in story_class.other_starter_intents():
+            if intent not in self.__stories_by_other_starter_intents:
+                self.__stories_by_other_starter_intents[intent] = []
+            self.__stories_by_other_starter_intents[intent].append(story_class)
+
+        for intent in story_class.secondary_intents():
+            if intent not in self.__stories_by_secondary_intents:
+                self.__stories_by_secondary_intents[intent] = []
+            self.__stories_by_secondary_intents[intent].append(story_class)
+
+    def find_story(self, intent: Intent, current_story: Type[Story]) -> Optional[Type[Story]]:
+
+        if current_story and current_story.support(current_story, intent):
+            return current_story
+
+        if intent in self.__stories_by_main_intent:
+            return self.__stories_by_main_intent[intent]
+
+        if intent in self.__stories_by_other_starter_intents and len(self.__stories_by_other_starter_intents[intent]) > 0:
+            return self.__stories_by_other_starter_intents[intent][0]
diff --git a/tock/tests/__init__.py b/tock/tests/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/tock/tests/test_schemas.py b/tock/tests/test_schemas.py
new file mode 100644
index 0000000..f04c159
--- /dev/null
+++ b/tock/tests/test_schemas.py
@@ -0,0 +1,358 @@
+# -*- coding: utf-8 -*-
+import json
+import unittest
+from datetime import datetime
+from unittest import TestCase
+
+from testfixtures import compare
+
+from tock.models import ConnectorType, Entity, Message, UserId, User, RequestContext, PlayerType, Suggestion, I18nText, \
+    Sentence, \
+    ResponseContext, BotRequest, BotResponse, TockMessage, Card, Attachment, AttachmentType, Action, Carousel
+from tock.schemas import ConnectorTypeSchema, EntitySchema, MessageSchema, UserIdSchema, UserSchema, \
+    RequestContextSchema, SuggestionSchema, \
+    I18nTextSchema, ResponseContextSchema, BotRequestSchema, BotResponseSchema, TockMessageSchema, \
+    CardSchema, SentenceSchema, AttachmentSchema, ActionSchema, CarouselSchema
+
+
+def given_bot_request() -> BotRequest:
+    return BotRequest(
+        intent="intent",
+        entities=[
+            Entity(
+                type="type",
+                role="role",
+                evaluated=True,
+                new=False,
+                content="content",
+                value="value"
+            )
+        ],
+        message=Message(
+            type="type",
+            text="text"
+        ),
+        story_id="story_id",
+        request_context=RequestContext(
+            namespace="namespace",
+            language="fr",
+            connector_type=ConnectorType(
+                id="id",
+                user_interface_type="text"
+            ),
+            user_interface="text",
+            application_id="application_id",
+            user_id=UserId(
+                id="id",
+                type=PlayerType.USER
+            ),
+            bot_id=UserId(
+                id="id",
+                type=PlayerType.BOT
+            ),
+            user=User(
+                timezone="timezone",
+                locale="fr_FR",
+                test=False
+            )
+        )
+    )
+
+
+def given_bot_response() -> BotResponse:
+    return BotResponse(
+        messages=[
+            given_sentence(),
+            given_card(),
+            given_carousel()
+        ],
+        story_id="story_id",
+        entities=[],
+        context=ResponseContext(
+            request_id="request_id",
+            date=datetime(2020, 1, 1, 0, 0, 0)
+        ),
+        step="step"
+    )
+
+
+def given_i18n_text(text: str = "text") -> I18nText:
+    return I18nText(
+        text=text,
+        args=["one", "two", "three"],
+        to_be_translated=True,
+        length=4,
+        key="key"
+    )
+
+
+def given_sentence() -> Sentence:
+    return Sentence(
+        text=given_i18n_text(),
+        suggestions=[
+            given_suggestion("action1"),
+            given_suggestion("action2")
+        ],
+        delay=0
+    )
+
+
+def given_attachment() -> Attachment:
+    return Attachment(
+        url="http://image.svg",
+        type=AttachmentType.IMAGE
+    )
+
+
+def given_action() -> Action:
+    return Action(
+        title=given_i18n_text("action"),
+        url="http://action.com"
+    )
+
+
+def given_card() -> Card:
+    return Card.Builder() \
+        .with_title(given_i18n_text()) \
+        .with_sub_title(given_i18n_text()) \
+        .with_attachment("http://image.svg", AttachmentType.IMAGE) \
+        .add_action(given_i18n_text("action"), "http://action.com") \
+        .with_delay(0) \
+        .build()
+
+
+def given_carousel() -> Carousel:
+    return Carousel.Builder() \
+        .add_card(given_card()) \
+        .add_card(given_card()) \
+        .add_card(given_card()) \
+        .build()
+
+
+def given_user_id() -> UserId:
+    return UserId(
+        id="id",
+        type=PlayerType.USER,
+        client_id="client_id"
+    )
+
+
+def given_entity() -> Entity:
+    return Entity(
+        type="type",
+        role="role",
+        evaluated=True,
+        new=False,
+        content="content",
+        value="value"
+    )
+
+
+def given_user() -> User:
+    return User(
+        timezone="timezone",
+        locale="fr_FR",
+        test=False
+    )
+
+
+def given_response_context() -> ResponseContext:
+    return ResponseContext(
+        request_id="request_id",
+        date=datetime(2020, 1, 1, 0, 0, 0)
+    )
+
+
+def given_suggestion(title: str = "action") -> Suggestion:
+    return Suggestion(
+        title=given_i18n_text(title)
+    )
+
+
+def given_message() -> Message:
+    return Message(
+        type="type",
+        text="text"
+    )
+
+
+def given_connector_type() -> ConnectorType:
+    return ConnectorType(
+        id="id",
+        user_interface_type="text"
+    )
+
+
+def given_request_context() -> RequestContext:
+    return RequestContext(
+        namespace="namespace",
+        language="fr",
+        connector_type=given_connector_type(),
+        user_interface="text",
+        application_id="application_id",
+        user_id=given_user_id(),
+        bot_id=given_user_id(),
+        user=given_user()
+    )
+
+
+def given_tock_message() -> TockMessage:
+    return TockMessage(
+        request_id="request_id",
+        bot_request=given_bot_request(),
+        bot_response=given_bot_response()
+    )
+
+
+class TestEntitySchema(TestCase):
+    def test_json_serialization(self):
+        expected = given_entity()
+        schema = EntitySchema()
+        result = schema.load(json.loads(schema.dumps(expected)))
+        compare(expected, result)
+
+
+class TestMessageSchema(TestCase):
+    def test_json_serialization(self):
+        expected = given_message()
+        schema = MessageSchema()
+        result: Message = schema.load(json.loads(schema.dumps(expected)))
+        compare(expected, result)
+
+
+class TestConnectorTypeSchema(TestCase):
+    def test_json_serialization(self):
+        expected = given_connector_type()
+        schema = ConnectorTypeSchema()
+        result: ConnectorType = schema.load(json.loads(schema.dumps(expected)))
+        compare(expected, result)
+
+
+class TestUserIdSchema(TestCase):
+    def test_json_serialization(self):
+        expected = given_user_id()
+        schema = UserIdSchema()
+        result: UserId = schema.load(json.loads(schema.dumps(expected)))
+        compare(expected, result)
+
+
+class TestUserSchema(TestCase):
+    def test_json_serialization(self):
+        expected = given_user()
+        schema = UserSchema()
+        result: User = schema.load(json.loads(schema.dumps(expected)))
+        compare(expected, result)
+
+
+class TestRequestContextSchema(TestCase):
+    def test_json_serialization(self):
+        expected = given_request_context()
+        schema = RequestContextSchema()
+        result: RequestContext = schema.load(json.loads(schema.dumps(expected)))
+        compare(expected, result)
+
+
+class TestSuggestionSchema(TestCase):
+    def test_json_serialization(self):
+        expected = given_suggestion()
+        schema = SuggestionSchema()
+        result: Suggestion = schema.load(json.loads(schema.dumps(expected)))
+        compare(expected, result)
+
+
+class TestI18nTextSchema(TestCase):
+    def test_json_serialization(self):
+        expected = given_i18n_text()
+        schema = I18nTextSchema()
+        result: I18nText = schema.load(json.loads(schema.dumps(expected)))
+        compare(expected, result)
+
+
+class TestSentenceSchema(TestCase):
+    def test_json_serialization(self):
+        expected = given_sentence()
+        schema = SentenceSchema()
+        dumps = schema.dumps(expected)
+        loads = json.loads(dumps)
+        result: Sentence = schema.load(loads)
+        compare(expected, result)
+
+
+class TestAttachmentSchema(TestCase):
+    def test_json_serialization(self):
+        expected = given_attachment()
+        schema = AttachmentSchema()
+        dumps = schema.dumps(expected)
+        loads = json.loads(dumps)
+        result: Attachment = schema.load(loads)
+        compare(expected, result)
+
+
+class TestActionSchema(TestCase):
+    def test_json_serialization(self):
+        expected = given_action()
+        schema = ActionSchema()
+        result: Action = schema.load(json.loads(schema.dumps(expected)))
+        compare(expected, result)
+
+
+class TestCardSchema(TestCase):
+    def test_json_serialization(self):
+        expected = given_card()
+        schema = CardSchema()
+        dumps = schema.dumps(expected)
+        loads = json.loads(dumps)
+        result: Card = schema.load(loads)
+        compare(expected, result)
+
+
+class TestCarouselSchema(TestCase):
+    def test_json_serialization(self):
+        expected = given_carousel()
+        schema = CarouselSchema()
+        dumps = schema.dumps(expected)
+        loads = json.loads(dumps)
+        result: Carousel = schema.load(loads)
+        compare(expected, result)
+
+
+class TestResponseContextSchema(TestCase):
+    def test_json_serialization(self):
+        expected = given_response_context()
+        schema = ResponseContextSchema()
+        dumps = schema.dumps(expected)
+        loads = json.loads(dumps)
+        result: Sentence = schema.load(loads)
+        compare(expected, result)
+
+
+class TestBotRequestSchema(TestCase):
+    def test_json_serialization(self):
+        expected = given_bot_request()
+        schema = BotRequestSchema()
+        dumps = schema.dumps(expected)
+        loads = json.loads(dumps)
+        result: BotRequest = schema.load(loads)
+        compare(expected, result)
+
+
+class TestBotResponseSchema(TestCase):
+    def test_json_serialization(self):
+        expected = given_bot_response()
+        schema = BotResponseSchema()
+        dumps = schema.dumps(expected)
+        loads = json.loads(dumps)
+        result: BotResponse = schema.load(loads)
+        compare(expected, result)
+
+
+class TestTockMessageSchema(TestCase):
+    def test_json_serialization(self):
+        expected = given_tock_message()
+        schema = TockMessageSchema()
+        result: TockMessage = schema.load(json.loads(schema.dumps(expected)))
+        compare(expected, result)
+
+
+if __name__ == '__main__':
+    unittest.main()
diff --git a/tock/webhook.py b/tock/webhook.py
index 28f39e2..385b7b6 100644
--- a/tock/webhook.py
+++ b/tock/webhook.py
@@ -4,6 +4,8 @@ from typing import Callable
 
 from aiohttp import web
 
+from tock.schemas import TockMessageSchema
+
 
 class TockWebhook:
     """
@@ -32,7 +34,7 @@ class TockWebhook:
     async def __webhook(self, request):
         self.__logger.debug("new event received")
         bot_request = await request.json()
-        tock_response = self.__bot_handler(bot_request)
+        tock_response = self.__bot_handler(TockMessageSchema().load(bot_request))
 
         self.__logger.debug("new event sent : " + tock_response)
         return web.Response(text=tock_response)
diff --git a/tock/websocket.py b/tock/websocket.py
index 01e15fc..936eb48 100644
--- a/tock/websocket.py
+++ b/tock/websocket.py
@@ -1,11 +1,14 @@
 # -*- coding: utf-8 -*-
 import json
 import logging
+import sys
 from json import JSONDecodeError
 from typing import Callable
 
 import aiohttp
-import sys
+
+from tock.models import TockMessage
+from tock.schemas import TockMessageSchema
 
 
 class TockWebsocket:
@@ -36,7 +39,8 @@ class TockWebsocket:
                 if msg.type == aiohttp.WSMsgType.TEXT:
                     try:
                         self.__logger.debug("new event received : " + msg.data)
-                        tock_response = self.__bot_handler(json.loads(msg.data))
+                        tock_message: TockMessage = TockMessageSchema().load(json.loads(msg.data))
+                        tock_response = self.__bot_handler(tock_message)
                         self.__logger.debug("new event sent : " + tock_response)
                         await ws.send_str(tock_response)
                     except JSONDecodeError:
